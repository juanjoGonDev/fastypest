name: 🔄 PRs Required QA Auto-Merge

on:
  schedule:
    - cron: "0 8 * * 6"
  workflow_dispatch:
    inputs:
      dry_run:
        description: "Do not actually merge, just simulate (for testing)"
        required: false
        default: "false"
        type: choice
        options:
          - "true"
          - "false"

run-name: 🔄 PRs Required QA Auto-Merge${{ github.event.inputs.dry_run == 'true' && ' (dry)' || '' }}

permissions:
  contents: write
  pull-requests: write

jobs:
  auto-merge-required-qa:
    name: Auto merge required QA${{ github.event.inputs.dry_run == 'true' && ' (dry)' || '' }}
    runs-on: ubuntu-latest
    environment: admin
    steps:
      - name: ⬇️ Checkout repo
        uses: actions/checkout@v4

      - name: 🔍 Search PRs requires-manual-qa
        id: search_prs
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prs = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              per_page: 100
            });
            // Filter by label, dependabot and base main
            const filtered = prs.data.filter(pr =>
              pr.labels.some(l => l.name === 'requires-manual-qa') &&
              pr.user.login === 'dependabot[bot]' &&
              pr.base.ref === 'main' &&
              pr.head.repo.full_name === `${context.repo.owner}/${context.repo.repo}`
            );
            return filtered.map(pr => pr.number);

      - name: 🤖 Process PRs
        if: steps.search_prs.outputs.result != '[]'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PAT_FINE }}
          script: |
            // Detect dry_run from workflow_dispatch or default to false
            const core = require('@actions/core');
            const dryRun = core.getInput('dry_run') === 'true';
            console.log(`Dry run mode: ${dryRun}`);

            let prNumbers = ${{ steps.search_prs.outputs.result }};
            if (typeof prNumbers === 'string') {
              try {
                prNumbers = JSON.parse(prNumbers);
              } catch {
                prNumbers = [];
              }
            }
            const results = [];
            for (const prNumber of prNumbers) {
              console.log(`PR #${prNumber}: Processing...`);

              // 1. Check if approved

              console.log(`PR #${prNumber}: Checking if  is approved...`);
              const reviews = await github.rest.pulls.listReviews({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });
              const approved = reviews.data.some(r => r.state === 'APPROVED');
              if (!approved) {
                console.log(`PR #${prNumber}: is NOT approved.`);
                results.push({prNumber, merged: false, reason: 'No approved'});
                continue;
              }
              console.log(`PR #${prNumber}: is approved.`);

              // 2. Updated with main

              let pr = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });
              let updated = pr.data.mergeable_state === 'clean';

              if (!updated) {
                console.log(`PR #${prNumber}: is NOT up-to-date. Attempting to update...`);
                try {
                  await github.rest.pulls.updateBranch({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: prNumber
                  });
                  console.log(`PR #${prNumber}: update triggered.`);
                  await new Promise(resolve => setTimeout(resolve, 15000));
                } catch (e) {
                  console.log(`PR #${prNumber}: update FAILED: ${e.message}`);
                  results.push({prNumber, merged: false, reason: 'Could not update branch: ' + e.message});
                  continue;
                }
              }

              // 3. Check required checks

              console.log(`PR #${prNumber}: Checking required checks...`);
              const ref = `refs/pull/${prNumber}/head`;
              const timeout = 5 * 60 * 1000; // 5 minutes
              const interval = 5000; // 5 seconds
              const deadline = Date.now() + timeout;

              let checksPassed = false;
              while (Date.now() < deadline) {
                const { data: checksData } = await github.rest.checks.listForRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref
               });

                const relevantChecks = checksData.check_runs.filter(run => run.conclusion !== 'skipped');
                const failed = relevantChecks.filter(run => run.conclusion === 'failure');
                const running = relevantChecks.filter(run => run.status !== 'completed');

                console.log(`PR #${prNumber}: ${relevantChecks.length - failed.length - running.length}/${relevantChecks.length} checks passed. ${running.length} still running.`);

                if (failed.length > 0) {
                  console.log(`PR #${prNumber}: Some checks failed.`);
                  break;
                }

                if (running.length === 0) {
                  console.log(`PR #${prNumber}: All required checks PASSED.`);
                  checksPassed = true;
                  break;
                }

                console.log(`PR #${prNumber}: Waiting for checks to complete. Running: ${running.length}/${relevantChecks.length}...`);
               await new Promise(resolve => setTimeout(resolve, interval));
              }

              if (!checksPassed) {
                results.push({ prNumber, merged: false, reason: 'Checks no OK (failure or still pending)' });
                continue;
              }

              // 4. Merge

              let merged = false;
              let mergeReason = '';
              if (dryRun) {
                console.log(`PR #${prNumber}: would be merged (dry run mode).`);
                mergeReason = 'Dry run: merge skipped';
              } else {
                try {
                  console.log(`PR #${prNumber}: Attempting merge using GITHUB_TOKEN...`);
                  // Re-authenticate Octokit with GITHUB_TOKEN just for the merge
                  const { Octokit } = require('@octokit/rest');
                  const mergeOctokit = new Octokit({ auth: process.env.GITHUB_TOKEN });
                  await mergeOctokit.pulls.merge({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: prNumber,
                    merge_method: 'squash'
                  });
                  merged = true;
                  mergeReason = 'Merged!';
                  console.log(`PR #${prNumber}: Merge successful.`);
                } catch (e) {
                  mergeReason = 'Merge failed: ' + e.message;
                  console.log(`PR #${prNumber}: Merge failed: ${e.message}`);
                }
              }

              results.push({prNumber, merged, reason: mergeReason});
            }
            console.table(results);
            return results;
