name: 🔄 PRs Required QA Auto-Merge

on:
  schedule:
    - cron: "0 8 * * 6"
  workflow_dispatch:
    inputs:
      dry_run:
        description: "Do not actually merge, just simulate (for testing)"
        required: false
        default: "false"
        type: choice
        options:
          - "true"
          - "false"

permissions:
  contents: write
  pull-requests: write

jobs:
  auto-merge-required-qa:
    runs-on: ubuntu-latest
    environment: admin
    steps:
      - name: ⬇️ Checkout repo
        uses: actions/checkout@v4

      - name: 🔍 Search PRs requires-manual-qa
        id: search_prs
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prs = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              per_page: 100
            });
            // Filter by label, dependabot and base main
            const filtered = prs.data.filter(pr =>
              pr.labels.some(l => l.name === 'requires-manual-qa') &&
              pr.user.login === 'dependabot[bot]' &&
              pr.base.ref === 'main' &&
              pr.head.repo.full_name === `${context.repo.owner}/${context.repo.repo}`
            );
            return filtered.map(pr => pr.number);

      - name: 🤖 Process PRs
        if: steps.search_prs.outputs.result != '[]'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PAT_FINE }}
          script: |
            // Detect dry_run from workflow_dispatch or default to false
            let dryRun = false;
            if (process.env.GITHUB_EVENT_NAME === 'workflow_dispatch') {
              dryRun = (process.env.INPUT_DRY_RUN || '').toLowerCase() === 'true';
            }
            const prNumbers = ${{ steps.search_prs.outputs.result }};
            const results = [];
            for (const prNumber of JSON.parse(prNumbers)) {
              // 1. Check if approved
              const reviews = await github.rest.pulls.listReviews({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });
              const approved = reviews.data.some(r => r.state === 'APPROVED');
              if (!approved) {
                results.push({prNumber, merged: false, reason: 'No approved'});
                continue;
              }
              // 2. Checks OK
              const checks = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: `refs/pull/${prNumber}/head`
              });
              const requiredChecks = checks.data.check_runs.filter(run => run.conclusion !== 'skipped');
              const allChecksPassed = requiredChecks.every(run => run.status === 'completed' && run.conclusion === 'success');
              if (!allChecksPassed) {
                results.push({prNumber, merged: false, reason: 'Checks no OK'});
                continue;
              }
              // 3. Updated with main
              let pr = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });
              if (pr.data.mergeable_state !== 'clean') {
                // Try to update the branch to main
                try {
                  await github.rest.pulls.updateBranch({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: prNumber
                  });
                } catch (e) {
                  results.push({prNumber, merged: false, reason: 'Could not update branch: ' + e.message});
                  continue;
                }
                // Wait for PR to become up-to-date (mergeable_state === 'clean')
                let updated = false;
                for (let i = 0; i < 60; i++) { // Wait up to 10 minutes
                  await new Promise(res => setTimeout(res, 10000));
                  pr = await github.rest.pulls.get({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: prNumber
                  });
                  if (pr.data.mergeable_state === 'clean') {
                    updated = true;
                    break;
                  }
                }
                if (!updated) {
                  results.push({prNumber, merged: false, reason: 'Branch did not become up-to-date after update'});
                  continue;
                }
                // Wait for all required checks to pass (same logic as auto-release)
                const ref = pr.data.head.sha;
                const timeout = 10 * 60 * 1000; // 10 minutes
                const interval = 5000; // 5 seconds
                const deadline = Date.now() + timeout;
                let checksPassed = false;
                while (Date.now() < deadline) {
                  const { data: checks } = await github.rest.checks.listForRef({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    ref
                  });
                  const requiredChecks = checks.check_runs.filter(run => run.conclusion !== 'skipped');
                  const passedChecks = requiredChecks.filter(run => run.status === 'completed' && run.conclusion === 'success').length;
                  const allPassed = passedChecks === requiredChecks.length;
                  if (allPassed) {
                    checksPassed = true;
                    break;
                  }
                  const anyFailed = requiredChecks.some(run => run.conclusion === 'failure');
                  if (anyFailed) {
                    break;
                  }
                  await new Promise(res => setTimeout(res, interval));
                }
                if (!checksPassed) {
                  results.push({prNumber, merged: false, reason: 'Checks did not pass after update'});
                  continue;
                }
              }
              // 4. Merge (unless dry_run)
              if (dryRun) {
                results.push({prNumber, merged: false, reason: 'Dry run: merge skipped'});
              } else {
                await github.rest.pulls.merge({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                  merge_method: 'squash'
                });
                results.push({prNumber, merged: true, reason: 'Merged!'});
              }
            }
            console.table(results);
            return results;
