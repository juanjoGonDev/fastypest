name: 🔄 PRs Required QA Auto-Merge

on:
  schedule:
    - cron: "0 8 * * 6"
  workflow_dispatch:
    inputs:
      dry_run:
        description: "Do not actually merge, just simulate (for testing)"
        required: false
        default: "false"
        type: choice
        options:
          - "true"
          - "false"

permissions:
  contents: write
  pull-requests: write

jobs:
  auto-merge-required-qa:
    runs-on: ubuntu-latest
    environment: admin
    steps:
      - name: ⬇️ Checkout repo
        uses: actions/checkout@v4

      - name: 🔍 Search PRs requires-manual-qa
        id: search_prs
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prs = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              per_page: 100
            });
            // Filter by label, dependabot and base main
            const filtered = prs.data.filter(pr =>
              pr.labels.some(l => l.name === 'requires-manual-qa') &&
              pr.user.login === 'dependabot[bot]' &&
              pr.base.ref === 'main' &&
              pr.head.repo.full_name === `${context.repo.owner}/${context.repo.repo}`
            );
            return filtered.map(pr => pr.number);

      - name: 🤖 Process PRs
        if: steps.search_prs.outputs.result != '[]'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PAT_FINE }}
          script: |
            // Detect dry_run from workflow_dispatch or default to false
            let dryRun = false;
            if (process.env.GITHUB_EVENT_NAME === 'workflow_dispatch') {
              dryRun = (process.env.INPUT_DRY_RUN || '').toLowerCase() === 'true';
            }
            let prNumbers = ${{ steps.search_prs.outputs.result }};
            if (typeof prNumbers === 'string') {
              try {
                prNumbers = JSON.parse(prNumbers);
              } catch {
                prNumbers = [];
              }
            }
            const results = [];
            for (const prNumber of prNumbers) {
              console.log(`PR #${prNumber}: Processing...`);

              // 1. Check if approved

              console.log(`PR #${prNumber}: Checking if  is approved...`);
              const reviews = await github.rest.pulls.listReviews({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });
              const approved = reviews.data.some(r => r.state === 'APPROVED');
              if (!approved) {
                console.log(`PR #${prNumber}: is NOT approved.`);
                results.push({prNumber, merged: false, reason: 'No approved'});
                continue;
              }
              console.log(`PR #${prNumber}: is approved.`);

              // 2. Updated with main

              let pr = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });
              if (pr.data.mergeable_state !== 'clean') {
                console.log(`PR #${prNumber}: is NOT up-to-date with main. Attempting to update branch...`);
                // Try to update the branch to main
                try {
                  await github.rest.pulls.updateBranch({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: prNumber
                  });
                  console.log(`PR #${prNumber}: branch update triggered.`);
                } catch (e) {
                  console.log(`PR #${prNumber}: branch update FAILED: ${e.message}`);
                  results.push({prNumber, merged: false, reason: 'Could not update branch: ' + e.message});
                  continue;
                }
                // Wait for PR to become up-to-date (mergeable_state === 'clean')
                let updated = false;
                for (let i = 0; i < 12; i++) { // Wait up to 1 minute
                  await new Promise(res => setTimeout(res, 5000));
                  pr = await github.rest.pulls.get({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: prNumber
                  });
                  if (pr.data.mergeable_state === 'clean') {
                    updated = true;
                    console.log(`PR #${prNumber}: is now up-to-date.`);
                    break;
                  }
                }
                if (!updated) {
                  console.log(`PR #${prNumber}: did NOT become up-to-date after update.`);
                  results.push({prNumber, merged: false, reason: 'Branch did not become up-to-date after update'});
                  continue;
                }
                console.log(`PR #${prNumber}: is now up-to-date.`);
              }

              // 3. Check required checks

              console.log(`PR #${prNumber}: Checking required checks...`);
              const ref = `refs/pull/${prNumber}/head`;
              const timeout = 5 * 60 * 1000; // 5 minutes
              const interval = 5000; // 5 seconds
              const deadline = Date.now() + timeout;

              let checksPassed = false;
              while (Date.now() < deadline) {
                const { data: checksData } = await github.rest.checks.listForRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref
               });

                const relevantChecks = checksData.check_runs.filter(run => run.conclusion !== 'skipped');
                const failed = relevantChecks.filter(run => run.conclusion === 'failure');
                const running = relevantChecks.filter(run => run.status !== 'completed');

                console.log(`PR #${prNumber}: ${relevantChecks.length - failed.length - running.length}/${relevantChecks.length} checks passed. ${running.length} still running.`);

                if (failed.length > 0) {
                  console.log(`PR #${prNumber}: Some checks failed.`);
                  break;
                }

                if (running.length === 0) {
                  console.log(`PR #${prNumber}: All required checks PASSED.`);
                  checksPassed = true;
                  break;
                }

                console.log(`PR #${prNumber}: Waiting for checks to complete. Running: ${running.length}/${relevantChecks.length}...`);
               await new Promise(resolve => setTimeout(resolve, interval));
              }

              if (!checksPassed) {
                results.push({ prNumber, merged: false, reason: 'Checks no OK (failure or still pending)' });
                continue;
              }

              // 4. Merge

              let merged = false;
              let mergeReason = '';
              if (dryRun) {
                console.log(`PR #${prNumber}: would be merged (dry run mode).`);
                mergeReason = 'Dry run: merge skipped';
              } else {
                try {
                  console.log(`PR #${prNumber}: Attempting merge...`);
                  await github.rest.pulls.merge({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: prNumber,
                    merge_method: 'squash'
                  });
                  merged = true;
                  mergeReason = 'Merged!';
                  console.log(`PR #${prNumber}: Merge successful.`);
                } catch (e) {
                  mergeReason = 'Merge failed: ' + e.message;
                  console.log(`PR #${prNumber}: Merge failed: ${e.message}`);
                }
              }

              results.push({prNumber, merged, reason: mergeReason});
            }
            console.table(results);
            return results;
